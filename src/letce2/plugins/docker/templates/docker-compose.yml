#
# Docker Compose Configuration
# Generated by letce2-plugin-docker
#
<%
import re
from collections import defaultdict
from letce2.utils.network import CIDRNotation

host_bridge=defaultdict(dict)
for key in context.keys():
  m = re.match(r'bridge\.(\d+)\.(.+)', key)
  if m:
    id = int(m.group(1))
    opt = m.group(2)
    val = context[key]
    host_bridge[id][opt] = val
    if opt == 'ipv4':
      host_bridge[id]['subnet'] = CIDRNotation.network(val)+'/'+str(CIDRNotation.prefix_length(val))
      host_bridge[id]['gateway'] = CIDRNotation.address(val)

bridges = defaultdict(lambda: defaultdict(dict))
for node,items in __share.items():
    for k, v in items.items():
        m = re.match(r'docker\.interface.(\d+)\.link',k)
        if m:
            bridges[node][m.group(1)]['link'] = v
        m = re.match(r'docker\.interface.(\d+)\.ipv4',k)
        if m:
            bridges[node][m.group(1)]['net'] = CIDRNotation.address(v)
%>

services:
% for node, index in __node_index.items():
  % if node != 'host':
  ${node}-emane:
    image: ${emane_image}
    container_name: letce2-${node}-emane
    hostname: ${node}-emane
    cap_add:
      - NET_ADMIN
      - SYS_NICE
    volumes:
      - ${__top_dir}/${node}:/experiment/${node}:ro
      - ${__top_dir}/persist/${node}:/experiment/persist/${node}:rw
    command: ["sleep", "infinity"]
    networks:
      default: {}
  % for bridge_id, bridge_opts in bridges.get(node, {}).items():
      ${host_bridge[int(bridge_id)].get('name','ota' + str(bridge_id))}:
        ipv4_address: ${bridge_opts['net']}
  % endfor

  ${node}-biz:
    image: ${biz_image}
    container_name: letce2-${node}-biz
    hostname: ${node}-biz
    cap_add:
      - NET_ADMIN
      - SYS_NICE
    volumes:
      - ${__top_dir}/${node}:/experiment/${node}:ro
      - ${__top_dir}/persist/${node}-biz:/experiment/persist/${node}-biz:rw
    command: ["sleep", "infinity"]
  % endif
% endfor

networks:
% for bridge_id, bridge_opts in host_bridge.items():
  ${bridge_opts.get('name','ota' + str(bridge_id))}:
    driver: bridge
    ipam:
      config:
        - subnet: ${bridge_opts['subnet']}
          gateway: ${bridge_opts['gateway']}
    driver_opts:
      com.docker.network.bridge.name: ${bridge_opts.get('name','ota' + str(bridge_id))}
      com.docker.network.bridge.enable_ip_masquerade: "false"
% endfor
